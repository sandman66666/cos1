# AI Chief of Staff - Essential Code That Tells The Story
# ========================================================
# This file contains only the unique innovations and core logic
# Mundane/standard code is listed with brief descriptions

## 1. CORE INNOVATION: KNOWLEDGE TREE FIRST ARCHITECTURE

### prompts/knowledge_tree/build_initial_tree.txt - The Master Knowledge Tree Builder
```
You are an expert business intelligence analyst tasked with creating a comprehensive knowledge tree from email data.

**User Context:**
- Email: {user_email}
- Business Domain: Technology/AI/Music
- Role: Executive/Entrepreneur

**Email Corpus Analysis:**
{emails_data}

Create a master knowledge tree that will serve as the foundation for ALL future email categorization. This tree must be:
- Comprehensive yet focused
- Hierarchical and well-organized
- Consistent in terminology
- Business-context aware

Return in this EXACT JSON format:
{{
  "topics": [
    {{
      "name": "Topic Name",
      "description": "Detailed description",
      "keywords": ["keyword1", "keyword2"],
      "strategic_importance": 0.8,
      "subtopics": ["Sub-topic 1", "Sub-topic 2"]
    }}
  ],
  "people": [
    {{
      "name": "Person Name",
      "email": "email@domain.com",
      "company": "Company Name",
      "role": "Their Role",
      "relationship_strength": 0.9,
      "primary_topics": ["Topic they're involved in"]
    }}
  ],
  "projects": [
    {{
      "name": "Project Name",
      "description": "Project description",
      "status": "active/planning/completed",
      "priority": "high/medium/low",
      "key_people": ["person1@email.com", "person2@email.com"],
      "related_topics": ["Topic 1", "Topic 2"]
    }}
  ]
}}

CRITICAL: This tree will be used to categorize ALL future emails. Ensure consistency and comprehensiveness.
```

### api/routes/email_routes.py - Knowledge Tree Management
```python
def get_master_knowledge_tree(user_id):
    """Get the master knowledge tree - the heart of the system"""
    tree_file = f"knowledge_trees/user_{user_id}_master_tree.json"
    if os.path.exists(tree_file):
        with open(tree_file, 'r') as f:
            return json.load(f)
    return None

@email_bp.route('/knowledge/foundation/build-from-bulk-emails', methods=['POST'])
@require_auth
def api_build_knowledge_foundation():
    """Build the knowledge foundation from ALL emails as a corpus"""
    # Get ALL emails, not individual processing
    all_emails = get_db_manager().get_user_emails(db_user.id, limit=None)
    
    # Aggregate into mega-corpus
    emails_data = []
    for email in all_emails:
        if email.body_clean or email.snippet:
            emails_data.append({
                'subject': email.subject,
                'content': email.body_clean or email.snippet,
                'sender': email.sender,
                'date': email.email_date.isoformat() if email.email_date else None
            })
    
    # Build master knowledge tree
    tree_prompt = load_prompt("knowledge_tree", "build_initial_tree", 
                             user_email=user_email, 
                             emails_data=json.dumps(emails_data, indent=2))
    
    # Send to Claude for comprehensive analysis
    response = claude_client.messages.create(
        model="claude-3-5-sonnet-20241022",
        max_tokens=4000,
        messages=[{"role": "user", "content": tree_prompt}]
    )
    
    # Parse and store the master tree
    master_tree = json.loads(response.content[0].text)
    tree_file = f"knowledge_trees/user_{db_user.id}_master_tree.json"
    with open(tree_file, 'w') as f:
        json.dump(master_tree, f, indent=2)
    
    return jsonify({'success': True, 'tree': master_tree})
```

## 2. CONTACT TIER CLASSIFICATION SYSTEM - ENGAGEMENT-BASED INTELLIGENCE

### chief_of_staff_ai/processors/email_quality_filter.py
```python
class ContactTier(Enum):
    TIER_1 = "tier_1"           # High engagement - always respond to
    TIER_2 = "tier_2"           # Medium engagement - new or occasional 
    TIER_LAST = "tier_last"     # No engagement - consistently ignore
    UNCLASSIFIED = "unclassified"

class EmailQualityFilter:
    def _determine_contact_tier(self, stats: ContactEngagementStats) -> Tuple[ContactTier, str, bool]:
        """Core logic: Determine contact value based on ACTUAL engagement patterns"""
        
        # Tier 1: People you respond to regularly (HIGH QUALITY)
        if stats.response_rate >= self.TIER_1_MIN_RESPONSE_RATE:  # 50%
            return ContactTier.TIER_1, f"High response rate ({stats.response_rate:.1%})", True
        
        # Tier LAST: People you consistently ignore (LOW QUALITY) 
        if (stats.emails_received >= self.TIER_LAST_MIN_EMAILS and 
            stats.response_rate <= self.TIER_LAST_MAX_RESPONSE_RATE and  # 10%
            stats.days_since_last_email <= 60):
            return ContactTier.TIER_LAST, f"Low response rate ({stats.response_rate:.1%})", False
        
        # Default to Tier 2 (MEDIUM QUALITY)
        return ContactTier.TIER_2, f"Medium engagement ({stats.response_rate:.1%})", True

    def analyze_email_quality(self, email_data: Dict, user_id: int) -> EmailQualityResult:
        """Main entry point: Should we process this email based on sender tier?"""
        sender_email = self._extract_sender_email(email_data)
        sender_stats = self._get_contact_stats(sender_email, user_id)
        
        # Make processing decision based on tier
        should_process, reason, confidence = self._make_processing_decision(sender_stats, email_data)
        
        return EmailQualityResult(
            should_process=should_process,
            tier=sender_stats.tier,
            reason=reason,
            confidence=confidence
        )
```

## 3. TACTICAL TASK EXTRACTION - HIGH CONFIDENCE ONLY

### prompts/task_extraction/tactical_task_extraction.txt
```
You are a tactical task extraction specialist. Extract ONLY high-confidence, specific, actionable tasks.

CRITICAL CRITERIA:
- Confidence threshold: 0.7+ only
- Must be SPECIFIC deliverables, not vague "follow up" 
- Must have clear business context
- Reject ambiguous or low-value tasks

**Email Content:**
{email_content}

**Business Context:**
{business_context}

Extract tasks in this JSON format:
{{
  "tasks": [
    {{
      "description": "Specific actionable task",
      "confidence": 0.8,
      "priority": "high/medium/low", 
      "due_date_text": "explicit or inferred deadline",
      "reasoning": "Why this is a valid tactical task"
    }}
  ]
}}

ONLY include tasks that meet ALL criteria. Better to extract 0 tasks than create noise.
```

### api/routes/task_routes.py
```python
@task_bp.route('/create-tactical', methods=['POST'])
@require_auth
def api_create_tactical_tasks():
    """Create only HIGH-CONFIDENCE tactical tasks"""
    
    # Get business context from knowledge tree
    master_tree = get_master_knowledge_tree(db_user.id)
    business_context = json.dumps(master_tree, indent=2) if master_tree else "No context available"
    
    # Get recent emails for processing
    recent_emails = get_db_manager().get_user_emails(db_user.id, limit=50)
    
    tasks_created = 0
    for email in recent_emails:
        if not email.body_clean:
            continue
            
        # Load tactical task extraction prompt
        task_prompt = load_prompt("task_extraction", "tactical_task_extraction",
                                 email_content=email.body_clean,
                                 business_context=business_context)
        
        # Extract tasks with Claude
        response = claude_client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1000,
            messages=[{"role": "user", "content": task_prompt}]
        )
        
        try:
            task_data = json.loads(response.content[0].text)
            
            # ONLY create tasks with confidence > 0.7
            for task in task_data.get('tasks', []):
                if task.get('confidence', 0) > 0.7:
                    create_task_in_database(task, email.id, db_user.id)
                    tasks_created += 1
                    
        except json.JSONDecodeError:
            continue
    
    return jsonify({'success': True, 'tasks_created': tasks_created})
```

## 4. PEOPLE AUGMENTATION WITH AI INTELLIGENCE

### api/routes/people_routes.py - The Heart of Contact Intelligence
```python
@people_bp.route('/augment-with-knowledge', methods=['POST'])
@require_auth  
def augment_people_with_knowledge():
    """Transform contacts into rich relationship intelligence using Claude"""
    
    # Only process Tier 1 contacts (people we actually engage with)
    tier1_people = []
    for person in all_people:
        contact_stats = email_quality_filter._get_contact_stats(person.email_address.lower(), db_user.id)
        if contact_stats.tier == ContactTier.TIER_1:
            tier1_people.append(person)
    
    for person in tier1_people:
        # Get email context with this person
        emails_with_person = session.query(Email).filter(
            (Email.sender.ilike(f'%{person.email_address}%') | 
             Email.recipient_emails.ilike(f'%{person.email_address}%'))
        ).limit(10).all()
        
        # Build intelligence prompt
        intelligence_prompt = f"""Analyze this professional contact:

**Contact:** {person.name} ({person.email_address})
**Recent Email Context:** {json.dumps(email_context, indent=2)}
**Knowledge Tree Context:** {json.dumps(tree_person, indent=2) if tree_person else 'None'}

Provide comprehensive analysis in JSON:
{{
  "professional_story": "2-3 sentence compelling narrative about relationship significance",
  "communication_style": "Analysis of communication patterns and preferred interaction style", 
  "key_topics": ["topic1", "topic2"],
  "skills": ["skill1", "skill2"],
  "personality_traits": ["trait1", "trait2"],
  "strategic_importance": 0.8,
  "relationship_insights": "What makes this relationship valuable"
}}"""
        
        # Get Claude's analysis
        response = claude_client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1000,
            messages=[{"role": "user", "content": intelligence_prompt}]
        )
        
        # Apply intelligence to person record
        intelligence_data = json.loads(response.content[0].text)
        person.professional_story = intelligence_data.get('professional_story')
        person.communication_style = intelligence_data.get('communication_style')
        person.key_topics = intelligence_data.get('key_topics')
        person.skills = intelligence_data.get('skills')
        person.importance_level = intelligence_data.get('strategic_importance', 0.5)
        # ... apply all fields
        
        people_enhanced += 1
```

## 5. THREE-STEP WORKFLOW ORCHESTRATION

### frontend/src/components/SettingsPage.tsx - The UI That Ties Everything Together
```typescript
// Step 1: Build Contact Base
const executeStep1 = async () => {
  const steps = [
    { name: 'Fetch Sent Emails', endpoint: '/api/email/fetch-sent-emails' },
    { name: 'Normalize Content', endpoint: '/api/email/normalize-emails' }, 
    { name: 'Build Contact Rules', endpoint: '/api/email-quality/build-contact-rules' },
    { name: 'Fetch Calendar Events', endpoint: '/api/calendar/fetch-events' }
  ];
  await executeSteps(steps);
};

// Step 2: Build Knowledge Tree (THE HEART)
const executeStep2 = async () => {
  const steps = [
    { name: 'Fetch All Emails', endpoint: '/api/email/fetch-all-emails' },
    { name: 'Build/Refine Tree', endpoint: '/api/knowledge/foundation/build-from-bulk-emails' },
    { name: 'Assign Emails to Tree', endpoint: '/api/knowledge/reorganize-content' }
  ];
  await executeSteps(steps);
};

// Step 3: Augment with Knowledge  
const executeStep3 = async () => {
  const steps = [
    { name: 'Create Tactical Tasks', endpoint: '/api/tasks/create-tactical' },
    { name: 'Augment People', endpoint: '/api/people/augment-with-knowledge' },
    { name: 'Augment Meetings', endpoint: '/api/calendar/augment-with-knowledge' }
  ];
  await executeSteps(steps);
};
```

## 6. INTELLIGENCE CHAT WITH KNOWLEDGE TREE CONTEXT

### prompts/intelligence_chat/enhanced_chat_system.txt
```
You are the AI Chief of Staff with deep knowledge of the user's business context.

**Business Knowledge Tree:**
{business_context}

**Recent Activity:**
{recent_activity}

**User Query:** {user_message}

Provide intelligent, context-aware responses that leverage the knowledge tree. Reference specific people, projects, and topics when relevant. Be proactive and strategic in your analysis.

Always ground your responses in the actual business context provided.
```

### api/routes/intelligence_routes.py
```python
@intelligence_bp.route('/chat', methods=['POST'])
@require_auth
def api_chat():
    """Enhanced Claude chat with REQUIRED business knowledge context"""
    
    # REQUIRE knowledge tree - no fallback chat
    master_tree = get_master_knowledge_tree(db_user.id)
    if not master_tree:
        return jsonify({
            'error': 'Knowledge tree required. Please complete Step 2: Build Knowledge Tree first.',
            'action_required': 'build_knowledge_tree'
        }), 400
    
    # Build context-aware prompt
    chat_prompt = load_prompt("intelligence_chat", "enhanced_chat_system",
                             business_context=json.dumps(master_tree, indent=2),
                             recent_activity=get_recent_activity_summary(db_user.id),
                             user_message=user_message)
    
    # Get intelligent response from Claude
    response = claude_client.messages.create(
        model="claude-3-5-sonnet-20241022", 
        max_tokens=2000,
        messages=[{"role": "user", "content": chat_prompt}]
    )
    
    return jsonify({
        'success': True,
        'response': response.content[0].text,
        'context_used': True,
        'knowledge_tree_stats': {
            'topics': len(master_tree.get('topics', [])),
            'people': len(master_tree.get('people', [])),
            'projects': len(master_tree.get('projects', []))
        }
    })
```

## 7. MUNDANE BUT NECESSARY FILES (Standard Implementation)

### Database Models
- `models/database.py` - Standard SQLAlchemy models (User, Email, Person, Task, Topic, etc.)
- `models/enhanced_models.py` - Additional relationship models

### Basic API Routes  
- `api/routes/auth_routes.py` - Standard OAuth 2.0 Google authentication
- `api/routes/calendar_routes.py` - Basic Google Calendar API integration
- `main.py` - Standard Flask app setup with blueprints

### Frontend Components
- `frontend/src/App.tsx` - Main React app shell with routing
- `frontend/src/components/Dashboard/` - Standard dashboard components
- `frontend/src/components/Tasks/` - Basic task list/detail views

### Configuration & Utilities
- `config/settings.py` - Environment variable configuration
- `requirements.txt` - Python dependencies
- `package.json` - Node.js dependencies  
- `Dockerfile` - Standard containerization

### External Integrations
- `chief_of_staff_ai/ingest/gmail_fetcher.py` - Gmail API client
- `chief_of_staff_ai/processors/email_normalizer.py` - Content cleaning

## 8. KEY INNOVATIONS SUMMARY

1. **Knowledge Tree First**: ALL emails analyzed as corpus to build master taxonomy
2. **Contact Tiers**: Engagement-based filtering (Tier 1 = respond to, Tier Last = ignore)  
3. **Tactical Tasks**: High-confidence threshold (0.7+) prevents task noise
4. **External Prompts**: AI behavior defined in text files for rapid iteration
5. **Three-Step Workflow**: Orchestrated intelligence building process
6. **Context-Aware Chat**: Claude with full business knowledge tree context
7. **Relationship Intelligence**: Claude-powered contact augmentation
8. **Universal Transparency**: Every UI element clickable to show source data

This architecture transforms email/calendar data into actionable business intelligence through semantic consistency, relationship analysis, and tactical precision. 